# scripts/backup-workflows.sh
#!/bin/bash

# AI SDR Dalvonete - Backup Script
# Autor: Sistema AI SDR
# Data: 2025-01-15

set -e

# Configurações
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="${BACKUP_DIR:-/backup/dalvonete}"
CONTAINER_NAME="n8n_dalvonete"
RETENTION_DAYS="${BACKUP_RETENTION_DAYS:-7}"

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}" >&2
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

# Criar diretório de backup
mkdir -p "$BACKUP_DIR"

log "Iniciando backup do AI SDR Dalvonete..."

# Backup do PostgreSQL
if systemctl is-active --quiet postgresql; then
    log "Fazendo backup do PostgreSQL..."
    pg_dump -U "${POSTGRES_USER}" -h "${POSTGRES_HOST}" "${POSTGRES_DB}" > "$BACKUP_DIR/postgres_$DATE.sql"
    if [ $? -eq 0 ]; then
        log "Backup PostgreSQL concluído: postgres_$DATE.sql"
    else
        error "Falha no backup do PostgreSQL"
        exit 1
    fi
else
    warn "PostgreSQL não está rodando, pulando backup do banco"
fi

# Backup dos workflows n8n
if docker ps | grep -q "$CONTAINER_NAME"; then
    log "Fazendo backup dos workflows n8n..."
    docker exec "$CONTAINER_NAME" n8n export:workflow --all --output="/tmp/workflows_$DATE.json"
    docker cp "$CONTAINER_NAME:/tmp/workflows_$DATE.json" "$BACKUP_DIR/"
    docker exec "$CONTAINER_NAME" rm "/tmp/workflows_$DATE.json"
    
    if [ -f "$BACKUP_DIR/workflows_$DATE.json" ]; then
        log "Backup workflows concluído: workflows_$DATE.json"
    else
        error "Falha no backup dos workflows"
        exit 1
    fi
else
    warn "Container n8n não está rodando, pulando backup dos workflows"
fi

# Backup das credenciais n8n (cuidado com segurança!)
if docker ps | grep -q "$CONTAINER_NAME"; then
    log "Fazendo backup das credenciais..."
    docker exec "$CONTAINER_NAME" n8n export:credentials --all --output="/tmp/credentials_$DATE.json"
    docker cp "$CONTAINER_NAME:/tmp/credentials_$DATE.json" "$BACKUP_DIR/"
    docker exec "$CONTAINER_NAME" rm "/tmp/credentials_$DATE.json"
    
    # Criptografar arquivo de credenciais
    if [ -f "$BACKUP_DIR/credentials_$DATE.json" ]; then
        gpg --symmetric --cipher-algo AES256 "$BACKUP_DIR/credentials_$DATE.json"
        rm "$BACKUP_DIR/credentials_$DATE.json"
        log "Backup credenciais concluído e criptografado: credentials_$DATE.json.gpg"
    fi
fi

# Backup do Redis (opcional)
if systemctl is-active --quiet redis-server; then
    log "Fazendo backup do Redis..."
    redis-cli --rdb "$BACKUP_DIR/redis_$DATE.rdb" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        log "Backup Redis concluído: redis_$DATE.rdb"
    else
        warn "Falha no backup do Redis"
    fi
fi

# Cleanup de backups antigos
log "Limpando backups antigos (>$RETENTION_DAYS dias)..."
find "$BACKUP_DIR" -name "*.sql" -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "*.json" -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "*.json.gpg" -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "*.rdb" -mtime +$RETENTION_DAYS -delete

# Compactar backup atual
log "Compactando backup..."
tar -czf "$BACKUP_DIR/dalvonete_backup_$DATE.tar.gz" -C "$BACKUP_DIR" \
    --exclude="*.tar.gz" \
    $(ls "$BACKUP_DIR" | grep "$DATE" | grep -v ".tar.gz")

# Remover arquivos individuais após compactação
rm -f "$BACKUP_DIR"/*_$DATE.sql "$BACKUP_DIR"/*_$DATE.json "$BACKUP_DIR"/*_$DATE.json.gpg "$BACKUP_DIR"/*_$DATE.rdb

log "Backup completo finalizado: dalvonete_backup_$DATE.tar.gz"

# Verificar tamanho do backup
BACKUP_SIZE=$(du -h "$BACKUP_DIR/dalvonete_backup_$DATE.tar.gz" | cut -f1)
log "Tamanho do backup: $BACKUP_SIZE"

# Opcional: enviar para armazenamento remoto
if [ ! -z "$AWS_S3_BUCKET" ]; then
    log "Enviando backup para S3..."
    aws s3 cp "$BACKUP_DIR/dalvonete_backup_$DATE.tar.gz" "s3://$AWS_S3_BUCKET/backups/"
fi

log "Backup script finalizado com sucesso!"

---

# scripts/restore-workflows.sh
#!/bin/bash

# AI SDR Dalvonete - Restore Script
# Restaura workflows e configurações

set -e

WORKFLOWS_DIR="./workflows"
CONTAINER_NAME="n8n_dalvonete"

log() {
    echo -e "\033[0;32m[$(date +'%Y-%m-%d %H:%M:%S')] $1\033[0m"
}

error() {
    echo -e "\033[0;31m[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1\033[0m" >&2
}

# Verificar se container está rodando
if ! docker ps | grep -q "$CONTAINER_NAME"; then
    error "Container n8n não está rodando. Execute: docker-compose up -d"
    exit 1
fi

log "Iniciando restauração dos workflows..."

# Aguardar n8n estar totalmente inicializado
log "Aguardando n8n inicializar..."
sleep 30

# Importar workflows na ordem correta
WORKFLOWS=(
    "mcp-dalvonete.json"
    "envia_video.json" 
    "cadastra_crm.json"
    "main-sdr-workflow.json"
)

for workflow in "${WORKFLOWS[@]}"; do
    if [ -f "$WORKFLOWS_DIR/$workflow" ]; then
        log "Importando $workflow..."
        docker cp "$WORKFLOWS_DIR/$workflow" "$CONTAINER_NAME:/tmp/$workflow"
        docker exec "$CONTAINER_NAME" n8n import:workflow --input="/tmp/$workflow"
        docker exec "$CONTAINER_NAME" rm "/tmp/$workflow"
        log "✓ $workflow importado com sucesso"
    else
        error "Arquivo não encontrado: $WORKFLOWS_DIR/$workflow"
    fi
done

log "Ativando workflows..."
docker exec "$CONTAINER_NAME" n8n update:workflow --all --active=true

log "Restauração concluída com sucesso!"
log "Acesse https://seu-dominio.com para configurar as credenciais"

---

# scripts/deploy.sh
#!/bin/bash

# Script de deploy automatizado

set -e

log() {
    echo -e "\033[0;32m[DEPLOY] $1\033[0m"
}

error() {
    echo -e "\033[0;31m[DEPLOY ERROR] $1\033[0m" >&2
    exit 1
}

# Verificar se está no diretório correto
if [ ! -f "docker-compose.yml" ]; then
    error "Execute o script no diretório raiz do projeto"
fi

# Verificar se .env existe
if [ ! -f ".env" ]; then
    error "Arquivo .env não encontrado. Copie de config/environment.example.env"
fi

log "Iniciando deploy do AI SDR Dalvonete..."

# Pull das imagens mais recentes
log "Atualizando imagens Docker..."
docker-compose pull

# Build e start dos serviços
log "Iniciando serviços..."
docker-compose up -d

# Aguardar serviços ficarem prontos
log "Aguardando serviços iniciarem..."
sleep 60

# Verificar se serviços estão rodando
if ! docker ps | grep -q "n8n_dalvonete"; then
    error "Container n8n não iniciou corretamente"
fi

if ! docker ps | grep -q "postgres_dalvonete"; then
    error "Container PostgreSQL não iniciou corretamente"
fi

if ! docker ps | grep -q "redis_dalvonete"; then
    error "Container Redis não iniciou corretamente"
fi

# Importar workflows se for primeira instalação
if [ "$1" = "--first-install" ]; then
    log "Primeira instalação detectada, importando workflows..."
    ./scripts/restore-workflows.sh
fi

# Verificar saúde da aplicação
log "Verificando saúde da aplicação..."
sleep 30

# Teste de conectividade
if ! curl -f -s http://localhost:5678 > /dev/null; then
    error "Aplicação não está respondendo na porta 5678"
fi

log "Deploy concluído com sucesso!"
log "Acesse: https://seu-dominio.com"
log "Para configurar SSL: certbot --nginx -d seu-dominio.com"

---

# scripts/health-check.sh
#!/bin/bash

# Script de verificação de saúde do sistema

ALERT_EMAIL="${ALERT_EMAIL:-admin@seu-dominio.com}"
WEBHOOK_URL="${WEBHOOK_URL:-http://localhost:5678}"

check_service() {
    local service_name=$1
    local check_command=$2
    
    if eval $check_command; then
        echo "✓ $service_name está funcionando"
        return 0
    else
        echo "✗ $service_name com problemas"
        return 1
    fi
}

send_alert() {
    local message=$1
    echo "$message" | mail -s "AI SDR Dalvonete - Alert" "$ALERT_EMAIL" 2>/dev/null || echo "Falha ao enviar email de alerta"
}

echo "=== Health Check AI SDR Dalvonete $(date) ==="

failed_checks=0

# Verificar containers Docker
if ! check_service "n8n Container" "docker ps | grep -q n8n_dalvonete"; then
    failed_checks=$((failed_checks + 1))
    send_alert "Container n8n está parado"
fi

if ! check_service "PostgreSQL Container" "docker ps | grep -q postgres_dalvonete"; then
    failed_checks=$((failed_checks + 1))
    send_alert "Container PostgreSQL está parado"
fi

if ! check_service "Redis Container" "docker ps | grep -q redis_dalvonete"; then
    failed_checks=$((failed_checks + 1))
    send_alert "Container Redis está parado"
fi

# Verificar conectividade HTTP
if ! check_service "n8n HTTP" "curl -f -s $WEBHOOK_URL > /dev/null"; then
    failed_checks=$((failed_checks + 1))
    send_alert "n8n não está respondendo HTTP"
fi

# Verificar uso de disco
disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
if [ "$disk_usage" -gt 85 ]; then
    echo "⚠ Uso de disco alto: ${disk_usage}%"
    send_alert "Uso de disco alto: ${disk_usage}%"
    failed_checks=$((failed_checks + 1))
else
    echo "✓ Uso de disco OK: ${disk_usage}%"
fi

# Verificar uso de memória
memory_usage=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
if [ "$memory_usage" -gt 90 ]; then
    echo "⚠ Uso de memória alto: ${memory_usage}%"
    send_alert "Uso de memória alto: ${memory_usage}%"
    failed_checks=$((failed_checks + 1))
else
    echo "✓ Uso de memória OK: ${memory_usage}%"
fi

echo "=== Resumo: $failed_checks falhas detectadas ==="

if [ $failed_checks -eq 0 ]; then
    exit 0
else
    exit 1
fi

---

# docs/API.md
# Documentação da API - AI SDR Dalvonete

## Visão Geral

O AI SDR Dalvonete utiliza webhooks para receber mensagens do WhatsApp e processa diferentes tipos de mídia através de workflows n8n.

## Webhook Principal

### Endpoint
```
POST https://seu-dominio.com/webhook/dalvonete
```

### Headers Obrigatórios
```
Content-Type: application/json
```

### Estrutura da Requisição

#### Mensagem de Texto
```json
{
  "body": {
    "text": {
      "message": "Olá, tenho interesse no chalé"
    },
    "phone": "5537999999999",
    "senderName": "João Silva",
    "isGroup": false,
    "fromMe": false,
    "fromApi": false,
    "messageId": "msg_123456789",
    "momment": "2025-01-15T10:30:00.000Z"
  }
}
```

#### Mensagem de Áudio
```json
{
  "body": {
    "audio": {
      "audioUrl": "https://api.z-api.io/instances/.../download/audio.ogg",
      "mimeType": "audio/ogg"
    },
    "phone": "5537999999999",
    "senderName": "João Silva",
    "isGroup": false,
    "fromMe": false,
    "fromApi": false,
    "messageId": "msg_123456789",
    "momment": "2025-01-15T10:30:00.000Z"
  }
}
```

#### Mensagem de Imagem
```json
{
  "body": {
    "image": {
      "imageUrl": "https://api.z-api.io/instances/.../download/image.jpg",
      "mimeType": "image/jpeg"
    },
    "phone": "5537999999999",
    "senderName": "João Silva",
    "isGroup": false,
    "fromMe": false,
    "fromApi": false,
    "messageId": "msg_123456789",
    "momment": "2025-01-15T10:30:00.000Z"
  }
}
```

#### Mensagem de Documento
```json
{
  "body": {
    "document": {
      "documentUrl": "https://api.z-api.io/instances/.../download/doc.pdf",
      "mimeType": "application/pdf",
      "filename": "documento.pdf"
    },
    "phone": "5537999999999",
    "senderName": "João Silva",
    "isGroup": false,
    "fromMe": false,
    "fromApi": false,
    "messageId": "msg_123456789",
    "momment": "2025-01-15T10:30:00.000Z"
  }
}
```

### Respostas

#### Sucesso (200)
```json
{
  "status": "received",
  "messageId": "msg_123456789",
  "processed": true
}
```

#### Erro (400)
```json
{
  "error": "Invalid request format",
  "details": "Missing required field: phone"
}
```

#### Erro (500)
```json
{
  "error": "Internal server error",
  "details": "Database connection failed"
}
```

## Fluxo de Processamento

### 1. Validação Inicial
- Verificação se é mensagem de grupo (rejeitada)
- Verificação se é mensagem da API (rejeitada)
- Validação do formato da mensagem

### 2. Controle de Atendimento
- Verificação se contato existe no Google Sheets
- Verificação se IA está travada para o número
- Criação/atualização do cadastro

### 3. Processamento de Mídia

#### Texto
- Processamento direto pelo agente IA

#### Áudio
- Download do arquivo
- Transcrição via OpenAI Whisper
- Processamento do texto resultante

#### Imagem
- Download do arquivo
- Análise se é documento via OpenAI Vision
- Se documento: extração de texto via Google Vision OCR
- Se imagem comum: análise descritiva via OpenAI Vision

#### Documento (PDF)
- Download do arquivo
- Análise se é documento oficial
- Se documento: extração via Google Vision PDF API
- Se documento comum: extração via OCR tradicional

### 4. Buffer de Mensagens
- Armazenamento temporário no Redis
- Agrupamento de mensagens em intervalo de 25 segundos
- Concatenação para envio ao agente IA

### 5. Processamento IA
- Análise do contexto e histórico (PostgreSQL)
- Identificação do intent (chalé vs evento)
- Execução do script de atendimento apropriado
- Geração de resposta

### 6. Envio de Resposta
- Quebra da resposta em mensagens menores
- Envio via Z-API com intervalo de 2 segundos
- Atualização da memória conversacional

## Integrações Externas

### CRM (Bubble.io)

#### Cadastrar Lead
```http
POST https://dalvonete.jaguarpartnes.com.br/api/1.1/obj/Deal
Authorization: Bearer {token}
Content-Type: application/json

{
  "Estagio": "1743361024092x852597106951848000",
  "Pipeline relacionado": "1743361186681x630044908701352000", 
  "Workspace": "1743361006470x605734445906919400",
  "Titulo": "João Silva",
  "telefone": "5537999999999",
  "cidade": "Divinópolis",
  "data": "2025-02-15"
}
```

#### Verificar Leads Existentes
```http
GET https://dalvonete.jaguarpartnes.com.br/api/1.1/obj/Deal
Authorization: Bearer {token}
```

### Google Calendar

#### Verificar Disponibilidade
```http
GET https://www.googleapis.com/calendar/v3/calendars/{calendarId}/events
Authorization: Bearer {token}
timeMin: 2025-02-15T00:00:00Z
timeMax: 2025-02-15T23:59:59Z
```

### Google Sheets

#### Verificar Status de Atendimento
```http
GET https://sheets.googleapis.com/v4/spreadsheets/{sheetId}/values/PÃ¡gina1
Authorization: Bearer {token}
```

#### Atualizar Status
```http
PUT https://sheets.googleapis.com/v4/spreadsheets/{sheetId}/values/PÃ¡gina1!A:D
Authorization: Bearer {token}

{
  "values": [
    ["João Silva", "5537999999999", "Sim", "2025-01-15 10:30:00"]
  ]
}
```

### Z-API (WhatsApp)

#### Enviar Mensagem de Texto
```http
POST https://api.z-api.io/instances/{instanceId}/token/{token}/send-text
Client-Token: {clientToken}
Content-Type: application/json

{
  "phone": "5537999999999",
  "message": "Olá! Em que posso ajudar?"
}
```

#### Enviar Vídeo
```http
POST https://api.z-api.io/instances/{instanceId}/token/{token}/send-video
Client-Token: {clientToken}
Content-Type: application/json

{
  "phone": "5537999999999", 
  "video": "data:video/mp4;base64,{base64_encoded_video}",
  "viewOnce": false
}
```

#### Enviar Imagem
```http
POST https://api.z-api.io/instances/{instanceId}/token/{token}/send-image
Client-Token: {clientToken}
Content-Type: application/json

{
  "phone": "5537999999999",
  "image": "data:image/jpeg;base64,{base64_encoded_image}",
  "viewOnce": false
}
```

## Rate Limiting

### Webhook
- 10 requisições por segundo por IP
- Burst de até 20 requisições

### APIs Externas
- OpenAI: Conforme limites da conta
- Google APIs: 100 requisições por 100 segundos por usuário
- Z-API: Conforme plano contratado

## Monitoramento

### Métricas Disponíveis
- Número de mensagens processadas
- Tempo de resposta médio
- Taxa de erro por tipo de mídia
- Status das integrações externas

### Logs
- Localização: `/var/log/n8n/`
- Formato: JSON estruturado
- Rotação: Diária com retenção de 30 dias

### Health Check
```http
GET https://seu-dominio.com/webhook/health
```

Resposta:
```json
{
  "status": "healthy",
  "services": {
    "n8n": "up",
    "postgres": "up", 
    "redis": "up"
  },
  "timestamp": "2025-01-15T10:30:00.000Z"
}
```

## Códigos de Erro

| Código | Descrição |
|--------|-----------|
| 200 | Mensagem processada com sucesso |
| 400 | Formato de requisição inválido |
| 401 | Token de autenticação inválido |
| 403 | Acesso negado (grupo/API) |
| 429 | Rate limit excedido |
| 500 | Erro interno do servidor |
| 502 | Erro de gateway (API externa) |
| 503 | Serviço temporariamente indisponível |

## Exemplos de Uso

### Teste de Conectividade
```bash
curl -X POST https://seu-dominio.com/webhook/dalvonete \
  -H "Content-Type: application/json" \
  -d '{
    "body": {
      "text": {"message": "teste"},
      "phone": "5537999999999",
      "senderName": "Teste",
      "isGroup": false,
      "fromMe": false,
      "fromApi": false,
      "messageId": "test123",
      "momment": "'$(date -Iseconds)'"
    }
  }'
```

### Simulação de Mensagem de Áudio
```bash
curl -X POST https://seu-dominio.com/webhook/dalvonete \
  -H "Content-Type: application/json" \
  -d '{
    "body": {
      "audio": {
        "audioUrl": "https://example.com/audio.ogg",
        "mimeType": "audio/ogg"
      },
      "phone": "5537999999999",
      "senderName": "Teste Audio",
      "isGroup": false,
      "fromMe": false,
      "fromApi": false,
      "messageId": "audio123",
      "momment": "'$(date -Iseconds)'"
    }
  }'
```

---

# LICENSE
MIT License

Copyright (c) 2025 AI SDR Dalvonete

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

# .gitignore
# Environment files
.env
.env.local
.env.production

# Credentials
config/credentials.json
*.key
*.pem
service-account-key.json

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Node modules
node_modules/

# Docker
.docker/

# Backup files
backups/
*.sql
*.rdb
*.tar.gz

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# n8n specific
.n8n/

# Temporary files
tmp/
temp/

# SSL certificates (except examples)
ssl/
*.crt
*.key
!ssl/README.md

---

# CHANGELOG.md
# Changelog

Todas as mudanças notáveis neste projeto serão documentadas neste arquivo.

O formato é baseado em [Keep a Changelog](https://keepachangelog.com/pt-BR/1.0.0/),
e este projeto adere ao [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Não Lançado]

### Planejado
- [ ] Dashboard de métricas em tempo real
- [ ] Integração com Telegram
- [ ] Suporte a múltiplos idiomas
- [ ] Sistema de templates personalizáveis

## [1.0.0] - 2025-01-15

### Adicionado
- Agente IA conversacional com GPT-4
- Processamento inteligente de múltiplos tipos de mídia:
  - Mensagens de texto
  - Transcrição de áudios via Whisper
  - Análise de imagens via Google Vision
  - Extração de texto de PDFs
- Sistema de memória conversacional com PostgreSQL
- Buffer inteligente de mensagens com Redis
- Integração completa com WhatsApp via Z-API
- Cadastro automático de leads no CRM (Bubble.io)
- Verificação de disponibilidade via Google Calendar
- Controle de atendimento via Google Sheets
- Scripts personalizados para chalé e eventos
- Sistema de backup automatizado
- Monitoramento de saúde dos serviços
- Deploy via Docker Compose
- Configuração SSL com Nginx
- Rate limiting e segurança

### Fluxos Implementados
- **Chalé**: Envio de vídeo → Coleta de data → Verificação disponibilidade → Cadastro
- **Eventos**: Identificação → Coleta de dados → Cadastro direto → Encaminhamento

### Integrações
- OpenAI GPT-4 e Whisper
- Google Vision API
- Google Calendar API  
- Google Sheets API
- Z-API WhatsApp Business
- CRM Bubble.io
- PostgreSQL
- Redis
- MCP Server

### Segurança
- Autenticação por tokens
- Criptografia de credenciais sensíveis
- Rate limiting por IP
- Validação de entrada de dados
- Logs estruturados sem dados sensíveis

### Documentação
- README completo com arquitetura
- Guia de instalação passo a passo
- Documentação da API
- Scripts de backup e restore
- Exemplos de uso e troubleshooting

## [0.1.0] - 2024-12-01

### Adicionado
- Protótipo inicial do agente IA
- Testes básicos de integração WhatsApp
- Estrutura inicial dos workflows n8n

---

Para ver o diff entre versões: `git log v0.1.0..v1.0.0 --oneline`